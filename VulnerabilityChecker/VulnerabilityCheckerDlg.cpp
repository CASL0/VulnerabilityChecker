
// VulnerabilityCheckerDlg.cpp : 実装ファイル
//

#include "pch.h"
#include "framework.h"
#include "VulnerabilityChecker.h"
#include "VulnerabilityCheckerDlg.h"
#include "afxdialogex.h"
#include <nlohmann/json.hpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CVulnerabilityCheckerDlg ダイアログ



CVulnerabilityCheckerDlg::CVulnerabilityCheckerDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_VULNERABILITYCHECKER_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CVulnerabilityCheckerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_ALERT, m_alertList);
}

BEGIN_MESSAGE_MAP(CVulnerabilityCheckerDlg, CDialogEx)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
END_MESSAGE_MAP()


// CVulnerabilityCheckerDlg メッセージ ハンドラー

BOOL CVulnerabilityCheckerDlg::OnInitDialog()
{
	(void)CDialogEx::OnInitDialog();

	(void)SetIcon(m_hIcon, TRUE);
	(void)SetIcon(m_hIcon, FALSE);

	EnableDynamicLayout(TRUE);
	(void)m_pDynamicLayout->Create(this);
	(void)m_pDynamicLayout->AddItem(IDC_LIST_ALERT, CMFCDynamicLayout::MoveNone(), CMFCDynamicLayout::SizeHorizontalAndVertical(100, 100));

	CString resourceStr;
	(void)resourceStr.LoadStringW(AFX_IDS_APP_TITLE);
	SetWindowText(resourceStr);

	(void)m_alertList.SetExtendedStyle(m_alertList.GetExtendedStyle() | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP);
	(void)resourceStr.LoadStringW(IDS_LIST_HEADER_1);
	(void)m_alertList.InsertColumn(0, resourceStr, LVCFMT_LEFT, 500);

	(void)resourceStr.LoadStringW(IDS_LIST_HEADER_2);
	(void)m_alertList.InsertColumn(1, resourceStr, LVCFMT_LEFT, 300);

	(void)resourceStr.LoadStringW(IDS_URL_JVN_ALERTLIST);
	if (auto ret = m_httpRequest.RequestUri(resourceStr.GetString(), cb, reinterpret_cast<DWORD_PTR>(this)); ret != ERROR_SUCCESS)
	{
		OutputDebugString(theApp.FormatErrorMessage(ret).c_str());
		(void)AfxMessageBox(theApp.FormatErrorMessage(ret).c_str());
		return FALSE;
	}

	return TRUE;  // フォーカスをコントロールに設定した場合を除き、TRUE を返します。
}

// ダイアログに最小化ボタンを追加する場合、アイコンを描画するための
//  下のコードが必要です。ドキュメント/ビュー モデルを使う MFC アプリケーションの場合、
//  これは、Framework によって自動的に設定されます。

void CVulnerabilityCheckerDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 描画のデバイス コンテキスト

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// クライアントの四角形領域内の中央
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// アイコンの描画
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

// ユーザーが最小化したウィンドウをドラッグしているときに表示するカーソルを取得するために、
//  システムがこの関数を呼び出します。
HCURSOR CVulnerabilityCheckerDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CALLBACK CVulnerabilityCheckerDlg::cb(HINTERNET hInternet, DWORD_PTR dwContext, DWORD dwInternetStatus, LPVOID lpvStatusInformation, DWORD dwStatusInformationLength)
{
	if (dwContext == NULL)
	{
		return;
	}

	auto dlg = reinterpret_cast<CVulnerabilityCheckerDlg*>(dwContext);
	dlg->OnResponse(hInternet, dwInternetStatus, lpvStatusInformation, dwStatusInformationLength);
}

void CVulnerabilityCheckerDlg::OnResponse(HINTERNET hInternet, DWORD dwInternetStatus, LPVOID lpvStatusInformation, DWORD dwStatusInformationLength)
{
	auto requestHandle = hInternet;
	switch (dwInternetStatus)
	{
	case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
	{
		auto size = *(reinterpret_cast<LPDWORD>(lpvStatusInformation));
		if (size == 0)
		{	//これ以上読み込むデータがないのでコールバック終了
			DisplayAlertList(m_httpResponseBody);
			std::vector<char> tmpVec;
			m_httpBuffer.swap(tmpVec);
			return;
		}

		m_httpBuffer.resize(size + 1);

		if (!WinHttpReadData(requestHandle, m_httpBuffer.data(), size, nullptr))
		{
			OutputDebugString(L"WinHttpReadData failed\n");
			return;
		}
		// → WINHTTP_CALLBACK_STATUS_READ_COMPLETE
	}
	break;
	case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
	{
		DWORD statusCode = 0;
		DWORD statusCodeSize = sizeof(DWORD);
		if (!WinHttpQueryHeaders(requestHandle, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, WINHTTP_HEADER_NAME_BY_INDEX, &statusCode, &statusCodeSize, WINHTTP_NO_HEADER_INDEX))
		{
			OutputDebugString(L"WinHttpQueryHeaders failed\n");
			return;
		}

		OutputDebugString(L"Status Code: ");
		OutputDebugString(std::to_wstring(statusCode).c_str());
		OutputDebugString(L"\n");
		switch (statusCode)
		{
		case 200:
			break;
		default:
			break;
		}

		if (!WinHttpQueryDataAvailable(requestHandle, nullptr))
		{
			OutputDebugString(L"WinHttpQueryDataAvailable failed\n");
			return;
		}
		// → WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
		break;
	}
	case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
		if (lpvStatusInformation && dwStatusInformationLength)
		{
			auto buffer = reinterpret_cast<char*>(lpvStatusInformation);
			buffer[dwStatusInformationLength] = '\0';
			m_httpResponseBody += buffer;

			// レスポンスデータデータ問い合わせ
			if (!WinHttpQueryDataAvailable(requestHandle, nullptr))
			{
				OutputDebugString(L"WinHttpQueryDataAvailable failed\n");
				return;
			}
			// → WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
		}
		break;
	case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
	{
		// WinHttpSendRequestの完了通知

		if (!WinHttpReceiveResponse(requestHandle, nullptr))
		{
			OutputDebugString(L"WinHttpReceiveResponse failed\n");
			return;
		}
		// → WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
		break;
	}
	case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:
		OutputDebugString(L"名前解決\n");
		OutputDebugString(reinterpret_cast<LPWSTR>(lpvStatusInformation));
		OutputDebugString(L"\n");
		break;
	case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
	{
		auto error = reinterpret_cast<WINHTTP_ASYNC_RESULT*>(lpvStatusInformation);
		CString errorMessage;
		errorMessage.Format(L"ID: %lu, error: %lu\n", error->dwResult, error->dwError);
		OutputDebugString(errorMessage.GetString());
		break;
	}
	default:
		break;
	}

}

void CVulnerabilityCheckerDlg::DisplayAlertList(const std::string& alertList)
{
	DWORD itemRow = 0;
	auto json = nlohmann::json::parse(alertList);
	for (const auto& elem : json["feed"]["entry"])
	{
		std::string title = elem.at("title").get<std::string>();
		(void)m_alertList.InsertItem(itemRow, theApp.Utf8ToUtf16(title).c_str());
		std::string updateDate = elem.at("update").get<std::string>();
		m_alertList.SetItemText(itemRow, 1, theApp.Utf8ToUtf16(updateDate).c_str());
		itemRow++;
	}
}