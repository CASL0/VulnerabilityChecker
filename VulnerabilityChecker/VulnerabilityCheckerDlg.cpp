
// VulnerabilityCheckerDlg.cpp : 実装ファイル
//

#include "pch.h"
#include "framework.h"
#include "VulnerabilityChecker.h"
#include "VulnerabilityCheckerDlg.h"
#include "VolnOverView.h"
#include "afxdialogex.h"
#include <PathCch.h>
#include <VersionHelpers.h>
#include <nlohmann/json.hpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CVulnerabilityCheckerDlg ダイアログ



CVulnerabilityCheckerDlg::CVulnerabilityCheckerDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_VULNERABILITYCHECKER_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CVulnerabilityCheckerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_ALERT, m_alertList);
}

BEGIN_MESSAGE_MAP(CVulnerabilityCheckerDlg, CDialogEx)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_ALERT, &CVulnerabilityCheckerDlg::OnLvnColumnclickListAlert)
	ON_MESSAGE(MESSAGE_DOWNLOAD_COMPLETE, CVulnerabilityCheckerDlg::OnDownloadComplete)
	ON_BN_CLICKED(IDC_BUTTON_DL_VERSION_CHECKER, &CVulnerabilityCheckerDlg::OnBnClickedButtonDLVersionChecker)
	ON_BN_CLICKED(IDC_BUTTON_LAUNCH_VERSION_CHECKER, &CVulnerabilityCheckerDlg::OnBnClickedButtonLaunchVersionChecker)
	ON_BN_CLICKED(IDC_BUTTON_DISPLAY_VOLN_OVERVIEW, &CVulnerabilityCheckerDlg::OnBnClickedButtonDisplayVolnOverview)
END_MESSAGE_MAP()


// CVulnerabilityCheckerDlg メッセージ ハンドラー

BOOL CVulnerabilityCheckerDlg::OnInitDialog()
{
	(void)CDialogEx::OnInitDialog();

	(void)SetIcon(m_hIcon, TRUE);
	(void)SetIcon(m_hIcon, FALSE);

	EnableDynamicLayout(TRUE);
	(void)m_pDynamicLayout->Create(this);
	(void)m_pDynamicLayout->AddItem(IDC_LIST_ALERT, CMFCDynamicLayout::MoveNone(), CMFCDynamicLayout::SizeHorizontalAndVertical(100, 100));
	(void)m_pDynamicLayout->AddItem(IDC_BUTTON_DL_VERSION_CHECKER, CMFCDynamicLayout::MoveHorizontalAndVertical(100, 100), CMFCDynamicLayout::SizeNone());
	(void)m_pDynamicLayout->AddItem(IDC_BUTTON_LAUNCH_VERSION_CHECKER, CMFCDynamicLayout::MoveHorizontalAndVertical(100, 100), CMFCDynamicLayout::SizeNone());
	(void)m_pDynamicLayout->AddItem(IDC_BUTTON_DISPLAY_VOLN_OVERVIEW, CMFCDynamicLayout::MoveHorizontalAndVertical(100, 100), CMFCDynamicLayout::SizeNone());

	CString resourceStr;
	(void)resourceStr.LoadStringW(AFX_IDS_APP_TITLE);
	SetWindowText(resourceStr);

	(void)resourceStr.LoadStringW(IDS_BUTTON_DL_VERSION_CHECKER);
	(void)GetDlgItem(IDC_BUTTON_DL_VERSION_CHECKER)->SetWindowTextW(resourceStr);

	(void)resourceStr.LoadStringW(IDS_BUTTON_LAUNCH_VERSION_CHECKER);
	(void)GetDlgItem(IDC_BUTTON_LAUNCH_VERSION_CHECKER)->SetWindowTextW(resourceStr);
	reinterpret_cast<CButton*>(GetDlgItem(IDC_BUTTON_LAUNCH_VERSION_CHECKER))->EnableWindow(FALSE);

	(void)resourceStr.LoadStringW(IDS_BUTTON_VOLN_OVERVIEW);
	(void)GetDlgItem(IDC_BUTTON_DISPLAY_VOLN_OVERVIEW)->SetWindowTextW(resourceStr);

	(void)m_alertList.SetExtendedStyle(m_alertList.GetExtendedStyle() | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP);
	(void)resourceStr.LoadStringW(IDS_LIST_HEADER_1);
	(void)m_alertList.InsertColumn(0, resourceStr, LVCFMT_LEFT, 500);

	(void)resourceStr.LoadStringW(IDS_LIST_HEADER_2);
	(void)m_alertList.InsertColumn(1, resourceStr, LVCFMT_LEFT, 200);

	(void)resourceStr.LoadStringW(IDS_LIST_HEADER_3);
	(void)m_alertList.InsertColumn(2, resourceStr, LVCFMT_LEFT, 300);

	CRect rect;
	GetWindowRect(&rect);
	(void)SetWindowPos(nullptr, rect.left, rect.top, 1000, rect.bottom - rect.top, SWP_SHOWWINDOW);

	(void)resourceStr.LoadStringW(IDS_URL_JVN_ALERTLIST);
	m_targetQue.push(DOWNLOAD_TARGET::MYJVN_ALERT_LIST);
	if (auto ret = m_httpRequest.RequestUri(resourceStr.GetString(), cb, reinterpret_cast<DWORD_PTR>(this)); ret != ERROR_SUCCESS)
	{
		OutputDebugString(theApp.FormatErrorMessage(ret).c_str());
		(void)AfxMessageBox(theApp.FormatErrorMessage(ret).c_str());
		return FALSE;
	}

	return TRUE;  // フォーカスをコントロールに設定した場合を除き、TRUE を返します。
}

// ダイアログに最小化ボタンを追加する場合、アイコンを描画するための
//  下のコードが必要です。ドキュメント/ビュー モデルを使う MFC アプリケーションの場合、
//  これは、Framework によって自動的に設定されます。

void CVulnerabilityCheckerDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 描画のデバイス コンテキスト

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// クライアントの四角形領域内の中央
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// アイコンの描画
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

// ユーザーが最小化したウィンドウをドラッグしているときに表示するカーソルを取得するために、
//  システムがこの関数を呼び出します。
HCURSOR CVulnerabilityCheckerDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CALLBACK CVulnerabilityCheckerDlg::cb(HINTERNET hInternet, DWORD_PTR dwContext, DWORD dwInternetStatus, LPVOID lpvStatusInformation, DWORD dwStatusInformationLength)
{
	if (dwContext == NULL)
	{
		return;
	}

	auto dlg = reinterpret_cast<CVulnerabilityCheckerDlg*>(dwContext);
	dlg->OnResponse(hInternet, dwInternetStatus, lpvStatusInformation, dwStatusInformationLength);
}

void CVulnerabilityCheckerDlg::OnResponse(HINTERNET hInternet, DWORD dwInternetStatus, LPVOID lpvStatusInformation, DWORD dwStatusInformationLength)
{
	auto requestHandle = hInternet;
	switch (dwInternetStatus)
	{
	case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
	{
		auto size = *(reinterpret_cast<LPDWORD>(lpvStatusInformation));
		if (size == 0)
		{	//これ以上読み込むデータがないのでコールバック終了
			OutputDebugString(L"Read complete: ");
			OutputDebugString(std::to_wstring(m_httpResponseBody.size()).c_str());
			OutputDebugString(L"bytes\n");
			m_httpResponseQue.push(m_httpResponseBody);
			PostMessage(MESSAGE_DOWNLOAD_COMPLETE, static_cast<WPARAM>(m_targetQue.front()), 0);
			m_targetQue.pop();
			std::vector<char> tmp;
			m_httpResponseBody.swap(tmp);
			return;
		}

		m_httpBuffer.resize(size);
		if (!WinHttpReadData(requestHandle, m_httpBuffer.data(), size, nullptr))
		{
			OutputDebugString(L"WinHttpReadData failed\n");
			return;
		}
		// → WINHTTP_CALLBACK_STATUS_READ_COMPLETE
	}
	break;
	case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
	{
		DWORD statusCode = 0;
		DWORD statusCodeSize = sizeof(DWORD);
		if (!WinHttpQueryHeaders(requestHandle, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, WINHTTP_HEADER_NAME_BY_INDEX, &statusCode, &statusCodeSize, WINHTTP_NO_HEADER_INDEX))
		{
			OutputDebugString(L"WinHttpQueryHeaders failed\n");
			return;
		}

		OutputDebugString(L"Status Code: ");
		OutputDebugString(std::to_wstring(statusCode).c_str());
		OutputDebugString(L"\n");
		switch (statusCode)
		{
		case 200:
			break;
		default:
			break;
		}

		if (!WinHttpQueryDataAvailable(requestHandle, nullptr))
		{
			OutputDebugString(L"WinHttpQueryDataAvailable failed\n");
			return;
		}
		// → WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
		break;
	}
	case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
		if (lpvStatusInformation && dwStatusInformationLength)
		{
			OutputDebugString(L"Read ");
			OutputDebugString(std::to_wstring(dwStatusInformationLength).c_str());
			OutputDebugString(L"bytes\n");

			m_httpResponseBody.reserve(m_httpResponseBody.size() + dwStatusInformationLength);
			std::copy(m_httpBuffer.begin(), m_httpBuffer.end(), std::back_inserter(m_httpResponseBody));
			std::vector<char> tmp;
			m_httpBuffer.swap(tmp);
			// レスポンスデータデータ問い合わせ
			if (!WinHttpQueryDataAvailable(requestHandle, nullptr))
			{
				OutputDebugString(L"WinHttpQueryDataAvailable failed\n");
				return;
			}
			// → WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
		}
		break;
	case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
	{
		// WinHttpSendRequestの完了通知

		if (!WinHttpReceiveResponse(requestHandle, nullptr))
		{
			OutputDebugString(L"WinHttpReceiveResponse failed\n");
			return;
		}
		// → WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
		break;
	}
	case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:
		OutputDebugString(L"名前解決\n");
		OutputDebugString(reinterpret_cast<LPWSTR>(lpvStatusInformation));
		OutputDebugString(L"\n");
		break;
	case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
	{
		auto error = reinterpret_cast<WINHTTP_ASYNC_RESULT*>(lpvStatusInformation);
		CString errorMessage;
		errorMessage.Format(L"ID: %lu, error: %lu\n", error->dwResult, error->dwError);
		OutputDebugString(errorMessage.GetString());
		break;
	}
	default:
		break;
	}

}

void CVulnerabilityCheckerDlg::DisplayAlertList(const std::string& alertList)
{
	DWORD itemRow = 0;
	auto json = nlohmann::json::parse(alertList);
	for (const auto& elem : json["feed"]["entry"])
	{
		std::string title = elem.at("title").get<std::string>();
		(void)m_alertList.InsertItem(itemRow, theApp.Utf8ToUtf16(title).c_str());
		std::string updateDate = elem.at("update").get<std::string>();
		(void)m_alertList.SetItemText(itemRow, 1, theApp.Utf8ToUtf16(updateDate).c_str());
		std::string id = elem.at("id").get<std::string>();
		(void)m_alertList.SetItemText(itemRow, 2, theApp.Utf8ToUtf16(id).c_str());
		itemRow++;
	}
}

int CALLBACK CVulnerabilityCheckerDlg::MyCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	auto dlg = reinterpret_cast<CVulnerabilityCheckerDlg*>(lParamSort);
	CString strItem1 = dlg->m_alertList.GetItemText(lParam1, dlg->m_subItem);
	CString strItem2 = dlg->m_alertList.GetItemText(lParam2, dlg->m_subItem);
	
	return dlg->m_sortAscending ? strItem1.Compare(strItem2) : strItem2.Compare(strItem1);
}

void CVulnerabilityCheckerDlg::OnLvnColumnclickListAlert(NMHDR* pNMHDR, LRESULT* pResult)
{
	LPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);
	m_subItem = pNMLV->iSubItem;
	m_alertList.SortItems(MyCompareProc, (LPARAM)this);

	for (auto i = 0; i < m_alertList.GetItemCount(); i++)
	{
		m_alertList.SetItemData(i, static_cast<DWORD>(i));
	}
	m_sortAscending = !m_sortAscending;
	*pResult = 0;
}

BOOL CVulnerabilityCheckerDlg::PreTranslateMessage(MSG* msg)
{
	switch (msg->message)
	{
	case WM_KEYDOWN:
		switch (msg->wParam)
		{
		case VK_RETURN:
		case VK_ESCAPE:
			return FALSE;
		default:
			break;
		}
		break;
	default:
		break;
	}

	return CDialog::PreTranslateMessage(msg);
}

LRESULT CVulnerabilityCheckerDlg::OnDownloadComplete(WPARAM wParam, LPARAM)
{
	if (m_httpResponseQue.empty())
	{
		return ERROR_SUCCESS;
	}

	std::vector<char> response = m_httpResponseQue.front();
	m_httpResponseQue.pop();
	switch (auto downloadTarget = static_cast<DOWNLOAD_TARGET>(wParam); downloadTarget)
	{
	case DOWNLOAD_TARGET::MYJVN_ALERT_LIST:
		DisplayAlertList(std::string(response.data(), response.size()));
		break;
	case DOWNLOAD_TARGET::MYJVN_VERSION_CHECKER:
	{
		ExpandVersionChecker(response);
		reinterpret_cast<CButton*>(GetDlgItem(IDC_BUTTON_DL_VERSION_CHECKER))->EnableWindow(FALSE);
		reinterpret_cast<CButton*>(GetDlgItem(IDC_BUTTON_LAUNCH_VERSION_CHECKER))->EnableWindow(TRUE);
		break;
	}
	default:
		break;
	}
	return ERROR_SUCCESS;
}

void CVulnerabilityCheckerDlg::OnBnClickedButtonDLVersionChecker()
{
	CString urlStr;
	(void)urlStr.LoadStringW(IDS_URL_JVN_VERSION_CHECKER);
	DownloadVersionChekcer(urlStr.GetString());

}

void CVulnerabilityCheckerDlg::DownloadVersionChekcer(const std::wstring& url)
{
	m_targetQue.push(DOWNLOAD_TARGET::MYJVN_VERSION_CHECKER);
	if (auto ret = m_httpRequest.RequestUri(url.c_str(), cb, reinterpret_cast<DWORD_PTR>(this)); ret != ERROR_SUCCESS)
	{
		OutputDebugString(theApp.FormatErrorMessage(ret).c_str());
		(void)AfxMessageBox(theApp.FormatErrorMessage(ret).c_str());
		return;
	}
}

void CVulnerabilityCheckerDlg::ExpandVersionChecker(const std::vector<char>& expandContents) const
{
	theApp.WriteContentsToFile(expandContents, L"MyJVN_.NET_DATA.zip");
	if (auto ret = ShellExecute(nullptr, L"open", L"powershell", L"Expand-Archive -Path MyJVN_.NET_DATA.zip", nullptr, SW_HIDE); reinterpret_cast<INT_PTR>(ret) <= 32)
	{
		OutputDebugString(theApp.FormatErrorMessage(reinterpret_cast<INT_PTR>(ret)).c_str());
		(void)AfxMessageBox(theApp.FormatErrorMessage(reinterpret_cast<INT_PTR>(ret)).c_str());
		return;
	}
}

void CVulnerabilityCheckerDlg::LaunchVersionChecker(const std::wstring& baseDir) const
{
	std::wstring batFile;
	if (IsWindows10OrGreater())
	{
		batFile = baseDir + L"MyJVN_.NET_GUI_Win10.bat";
	}
	else if (IsWindows8OrGreater())
	{
		batFile = baseDir + L"MyJVN_.NET_GUI_Win8.bat";
	}
	else
	{
		OutputDebugString(L"not supported\n");
		return;
	}
	OutputDebugString(batFile.c_str());
	OutputDebugString(L"\n");
	if (auto ret = ShellExecute(nullptr, L"open", batFile.c_str(), nullptr, baseDir.c_str(), SW_HIDE); reinterpret_cast<INT_PTR>(ret) <= 32)
	{
		OutputDebugString(theApp.FormatErrorMessage(reinterpret_cast<INT_PTR>(ret)).c_str());
		(void)AfxMessageBox(theApp.FormatErrorMessage(reinterpret_cast<INT_PTR>(ret)).c_str());
		return;
	}
}

void CVulnerabilityCheckerDlg::OnBnClickedButtonLaunchVersionChecker()
{
	std::vector<wchar_t> pathToExe(MAX_PATH);
	(void)GetModuleFileName(nullptr, pathToExe.data(), MAX_PATH);
	(void)PathCchRemoveFileSpec(pathToExe.data(), MAX_PATH);
	std::wstring baseDir(pathToExe.data());
	baseDir += L"\\MyJVN_.NET_DATA\\MyJVN_.NET_DATA\\1_Script_GUI\\";
	LaunchVersionChecker(baseDir);
}


void CVulnerabilityCheckerDlg::OnBnClickedButtonDisplayVolnOverview()
{
	VolnOverView dlg(this);
	(void)dlg.DoModal();
}
